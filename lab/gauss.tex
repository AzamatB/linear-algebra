\chapter{Gauss's Method}

\Sage{} can solve linear systems in a number of ways.
Here you will enter systems of linear equations,
both as equations and in the matrix form.
You will use those to solve the systems. 



\section{Systems}
To enter a system of equations you must first enter single equations, so 
you must enter variables.
We have seen one kind of variable in giving commands like these.
\begin{lstlisting}[style=python]
sage: x = 3
sage: 7*x
21  
\end{lstlisting}
Here $x$ is the name of a location to hold values.
For variables in equations we want something different; in the equation
$C=2\pi\cdot r$ the two variables do not necessarily have fixed values, nor
are they associated with a location in the computer's memory. 
To illustrate the difference enter this.
\begin{lstlisting}
sage: y
\end{lstlisting}
The response is \inlinecode{NameError: name 'y' is not defined} because
\Sage{} defaults to expecting that
$y$ is the name of a location that holds a value.
Instead, you need to
declare to the system that something is a symbolic variable.
\begin{lstlisting}
sage: var('x,y')
sage: x
x
\end{lstlisting}
With that, a system of equations is a list.
\begin{lstlisting}
sage: var('x,y,z')                                  
(x, y, z)
sage: eqns = [x-y+2*z == 4, 2*x+2*y == 12, x-4*z==5]
sage: solve(eqns, x,y,z)                            
[[x == 5, y == 1, z == 0]]
\end{lstlisting}
Note that you must write double equals \inlinecode{==} instead of 
the assignment operator \inlinecode{=} and also that
you must write \inlinecode{2*x}
instead of  
\inlinecode{2x}.
Either mistake will give you  
\inlinecode{SyntaxError: invalid syntax}.

You can put a parameter in the right side and solve for the variables
in terms of the parameter.
\begin{lstlisting}
sage: var('x,y,z,a')                                
(x, y, z, a)
sage: eqns = [x-y+2*z == a, 2*x+2*y == 12, x-4*z==5]
sage: solve(eqns, x,y,z)  
[[x == 2/5*a + 17/5, y == -2/5*a + 13/5, z == 1/10*a - 2/5]] 
\end{lstlisting}



\subsection{Matrices}
The \textit{solve} routine is general-purpose but 
for the special case of linear systems matrix notation is the best tool.
 
Most of your matrices have entries that are fractions.
\Sage{} uses `QQ' for the rational numbers,
`RR' for the reals,
`CC' for the complex numbers,
and
`ZZ' for the integers.
Also, you enter a row of the matrix as a list, and
you enter the entire matrix as a list of rows.
\begin{lstlisting}
sage: M = matrix(QQ, [[1, 2, 3], [4, 5, 6], [7 ,8, 9]])
sage: M
[1 2 3]
[4 5 6]
[7 8 9]
sage: M[1,2]
6
sage: M.nrows()
3
sage: M.ncols()
3
\end{lstlisting}
\Sage{} lists are zero-indexed, so \inlinecode{M[1,2]} asks
for the entry in the second row and third column. 

Enter a vector in much the same way.
\begin{lstlisting}
sage: v = vector(QQ, [2/3, -1/3, 1/2])
sage: v
(2/3, -1/3, 1/2)
sage: v[1]
-1/3
\end{lstlisting}
This is a column vector; 
it appears with rounded brackets so that 
it looks different than a one-row matrix.
Augment the matrix with this vector.
\begin{lstlisting}
sage: M_prime = M.augment(v)
sage: M_prime
[ 1  2  3 10]
[ 4  5  6 11]
[ 7  8  9 12]  
\end{lstlisting}
Have \Sage{} remember the distinction between the two parts 
of $M^\prime$.
\begin{lstlisting}
sage: M_prime = M.augment(v,subdivide=True)
sage: M_prime                              
[ 1  2  3|10]
[ 4  5  6|11]
[ 7  8  9|12] 
\end{lstlisting}



\subsection{Row operations}
Computers are good for jobs that are tedious and error-prone.
Row operations are both.

First enter an example matrix.
\begin{lstlisting}
sage: M = matrix(QQ, [[0, 2, 1], [2, 0, 4], [2 ,-1/2, 3]])
sage: v = vector(QQ, [2, 1, -1/2])                        
sage: M_prime = M.augment(v, subdivide=True)              
sage: M_prime                                             
[   0    2    1|   2]
[   2    0    4|   1]
[   2 -1/2    3|-1/2]
\end{lstlisting}
Swap the top rows (remember that row indices start at zero).
\begin{lstlisting}
sage: M_prime.swap_rows(0,1)
sage: M_prime
[   2    0    4|   1]
[   0    2    1|   2]
[   2 -1/2    3|-1/2]
\end{lstlisting}
Rescale the top row.
\begin{lstlisting}
sage: M_prime.rescale_row(0, 1/2)
sage: M_prime
[   1    0    2| 1/2]
[   0    2    1|   2]
[   2 -1/2    3|-1/2]  
\end{lstlisting}
Get a new  bottom row by adding $-2$~times the top to the current bottom
row.
\begin{lstlisting}
sage: M_prime.add_multiple_of_row(2,0,-2)
sage: M_prime
[   1    0    2| 1/2]
[   0    2    1|   2]
[   0 -1/2   -1|-3/2]  
\end{lstlisting}
Finish by finding echelon form.
\begin{lstlisting}
sage: M_prime.add_multiple_of_row(2,1,1/4)
sage: M_prime                             
[   1    0    2| 1/2]
[   0    2    1|   2]
[   0    0 -3/4|  -1]  
\end{lstlisting}
(By the way,
\Sage{} would have given us echelon form in a single operation 
had we run the command
\inlinecode{M_prime.echelon_form()}.)

Now by-hand back substitution gives the solution, or we can 
use \Sagecmd{solve}.
\begin{lstlisting}
sage: var('x,y,z')
sage: eqns=[-3/4*z == -1, 2*y+z == 2, x+2*z == 1/2]
sage: solve(eqns, x, y, z)
[[x == (-13/6), y == (1/3), z == (4/3)]]
\end{lstlisting}

% Needed?
The operations \Sagecmd{swap\_rows},
\Sagecmd{rescale\_rows}, and \Sagecmd{add\_multiple\_of\_row}
changed the matrix $M^\prime$.
\Sage{} has related commands that return a changed matrix
but leave the starting matrix unchanged.
\begin{lstlisting}
sage: M = matrix(QQ, [[1/2, 1, -1], [1, -2, 0], [2 ,-1, 1]])
sage: v = vector(QQ, [0, 1, -2])
sage: M_prime = M.augment(v, subdivide=True) 
sage: M_prime
[1/2   1  -1|  0]
[  1  -2   0|  1]
[  2  -1   1| -2]
sage: N = M_prime.with_rescaled_row(0,2)
sage: M_prime
[1/2   1  -1|  0]
[  1  -2   0|  1]
[  2  -1   1| -2]
sage: N      
[ 1  2 -2| 0]
[ 1 -2  0| 1]
[ 2 -1  1|-2]  
\end{lstlisting}
Here, $M^\prime$ is unchanged by the routine, while $N$ is the returned 
changed matrix.
The other two routines of this kind are \Sagecmd{with\_swapped\_rows} 
and \Sagecmd{with\_added\_multiple\_of\_row}.




\subsection{Nonsingular and singular systems}
Resorting to \Sagecmd{solve} after going through the row operations is artless.
\Sage{} will give reduced row echelon form straight from the augmented matrix.
\begin{lstlisting}
sage: M_prime.rref()
[    1     0     0|-13/6]
[    0     1     0|  1/3]
[    0     0     1|  4/3]
\end{lstlisting}

In that example the matrix~$M$ on the left is nonsingular because it is 
square and because Gauss's Method leads to echelon forms where every one of
$M$'s columns has a leading variable.
The next example starts with a different square matrix, a 
singular matrix, and consequently leads to 
echelon form systems where there are columns on the left 
that do not have a leading variable. 
\begin{lstlisting}
sage: M = matrix(QQ, [[1, 1, 1], [1, 2, 3], [2 , 3, 4]])    
sage: v = vector(QQ, [0, 1, 1]) 
sage: M_prime = M.augment(v, subdivide=True)
sage: M_prime
[1 1 1|0]
[1 2 3|1]
[2 3 4|1]
sage: M_prime.rref()
[ 1  0 -1|-1]
[ 0  1  2| 1]
[ 0  0  0| 0]  
\end{lstlisting}
Recall that the singular case  
has two subcases.
The first happens above: because in echelon form
every row that is all zeros on the
left has an entry on the right that is also zero,
the system has infinitely many solutions.
In contrast, with the same starting matrix
the example below has a row that is zeros on the left but is nonzero
on the right and so the system has no solution.
\begin{lstlisting}
sage: v = vector(QQ, [0, 1, 2])             
sage: M_prime = M.augment(v, subdivide=True)
sage: M_prime.rref()                        
[ 1  0 -1| 0]
[ 0  1  2| 0]
[ 0  0  0| 1]
\end{lstlisting}
The difference between the subcases
has to do with the relationships among  
the rows of~$M$ and the relationships among the rows of the vector.
In both cases, the relationship among the rows of the matrix~$M$
is that the first two rows add to the third.
In the first case the vector has the same relationship while in the second
it does not.

The easy way to ensure that a zero row in the matrix 
on the left is associated with a zero
entry in the vector on the right is to make the vector have all zeros, that is,
to consider the homogeneous system associated with~$M$.
\begin{lstlisting}
sage: v = zero_vector(QQ, 3)
sage: v
(0, 0, 0)
sage: M = matrix(QQ, [[1, 1, 1], [1, 2, 3], [2 , 3, 4]]) 
sage: M_prime = M.augment(v, subdivide=True)
sage: M_prime
[1 1 1|0]
[1 2 3|0]
[2 3 4|0]
sage: M_prime.rref()
[ 1  0 -1| 0]
[ 0  1  2| 0]
[ 0  0  0| 0]
\end{lstlisting}

You can get the numbers of the columns having leading entries with 
the \Sagecmd{pivots} method
(there is a complementary \Sagecmd{nonpivots}).
\begin{lstlisting}
sage: v = vector(QQ, [0, 1, 2])
sage: M_prime                  
[1 1 1|0]
[1 2 3|1]
[2 3 4|2]
sage: M_prime.pivots()         
(0, 1, 3)
sage: M_prime.rref()
[ 1  0 -1| 0]
[ 0  1  2| 0]
[ 0  0  0| 1]  
\end{lstlisting}
Because column~$2$ is not in the list of pivots we know that the
system is singular before we see it in echelon form.

We can use this observation to write a routine that decides if a 
square matrix is nonsingular.
\begin{lstlisting}
sage: def check_nonsingular(mat):
....:     if not(mat.is_square()):
....:         print "ERROR: mat must be square"
....:         return
....:     p = mat.pivots()
....:     for col in range(mat.ncols()):
....:         if not(col in p):
....:             print "nonsingular"
....:             break
....:          
sage: N = Matrix(QQ, [[1, 2, 3], [4, 5, 6], [7, 8, 9]])
sage: check_nonsingular(N)                                
nonsingular
sage: N = Matrix(QQ, [[1, 0, 0], [0, 1, 0], [0, 0, 1]])
sage: check_nonsingular(N)                                   
\end{lstlisting}
Actually, \Sage{} matrices already have a method \Sagecmd{is\_singular}
but this illustrates how you can write routines to extend \Sage.



\subsection{Parametrization}
You can use \Sagecmd{solve} to give the solution set of a system
with infinitely many solutions.
Start with the square matrix of coefficients from above,
where the top two rows add to the bottom row,
and adjoin a vector satisfying the same relationship to get
a system with infinitely many solutions.
Then convert that to a system of equations.
\begin{lstlisting}
sage: M = matrix(QQ, [[1, 1, 1], [1, 2, 3], [2 , 3, 4]])    
sage: v = vector(QQ, [1, 0, 1])                            
sage: M_prime = M.augment(v, subdivide=True)               
sage: M_prime                  
[1 1 1|1]
[1 2 3|0]
[2 3 4|1]
sage: eqns = [x+y+z == 1, x+2*y+3*z == 0, 2*x+3*y+4*z == 1]
sage: solve(eqns, x, y)   
[[x == z + 2, y == -2*z - 1]]  
sage: solve(eqns, x, y, z)                                 
[[x == r1 + 2, y == -2*r1 - 1, z == r1]]
\end{lstlisting}
The first of the two \Sagecmd{solve} calls asks \Sage{} 
to solve only for $x$ and~$y$ and so the solution is in terms of~$z$.
In the second call \Sage{} produces a parameter of its own.   




%========================================
\section{Automation}

We finish by showing two routines to automate the by-hand row reductions 
of the kind that the text has in the homework.
These use the matrix capabilities of \Sage{} to both describe 
and perform the row operations that bring a matrix to 
echelon form or to reduced echelon form. 

\subsection{Loading and running}
The source file of the script is below, at the end. 
First here are a few sample calls.
\begin{lstlisting}
sage: M = matrix(QQ, [[1/2, 1, 4], [2, 4, -1], [1, 2, 0]])          
sage: v = vector(QQ, [-2, 5, 4])
sage: M_prime = M.augment(v, subdivide=True)  
sage: gauss_method(M_prime)
[1/2   1   4| -2]
[  2   4  -1|  5]
[  1   2   0|  4]
 take -4 times row 1 plus row 2
 take -2 times row 1 plus row 3
[1/2   1   4| -2]
[  0   0 -17| 13]
[  0   0  -8|  8]
 take -8/17 times row 2 plus row 3
[  1/2     1     4|   -2]
[    0     0   -17|   13]
[    0     0     0|32/17]
\end{lstlisting}

The remaining examples skip the extra steps to make an augmented matrix. 
\begin{lstlisting}
sage: M1 = matrix(QQ, [[2, 0, 1, 3], [-1, 1/2, 3, 1], [0, 1, 7, 5]])
sage: gauss_method(M1)
[  2   0   1   3]
[ -1 1/2   3   1]
[  0   1   7   5]
 take 1/2 times row 1 plus row 2
[  2   0   1   3]
[  0 1/2 7/2 5/2]
[  0   1   7   5]
 take -2 times row 2 plus row 3
[  2   0   1   3]
[  0 1/2 7/2 5/2]
[  0   0   0   0]  
\end{lstlisting}

The script has a routine to go all the way to reduced echelon form.
\begin{lstlisting}
sage: M2 = matrix(QQ,
....:             [[1, 2, 3, 4], [1, 2, 3, 4],
....:              [2, 4, -1, 5], [1, 2, 0, 4]])
sage: gauss_jordan(M2)            
[ 1  2  3  4]
[ 1  2  3  4]
[ 2  4 -1  5]
[ 1  2  0  4]
 take -1 times row 1 plus row 2
 take -2 times row 1 plus row 3
 take -1 times row 1 plus row 4
[ 1  2  3  4]
[ 0  0  0  0]
[ 0  0 -7 -3]
[ 0  0 -3  0]
 swap row 2 with row 3
[ 1  2  3  4]
[ 0  0 -7 -3]
[ 0  0  0  0]
[ 0  0 -3  0]
 take -3/7 times row 2 plus row 4
[  1   2   3   4]
[  0   0  -7  -3]
[  0   0   0   0]
[  0   0   0 9/7]
 swap row 3 with row 4
[  1   2   3   4]
[  0   0  -7  -3]
[  0   0   0 9/7]
[  0   0   0   0]
 take -1/7 times row 2
 take 7/9 times row 3
[  1   2   3   4]
[  0   0   1 3/7]
[  0   0   0   1]
[  0   0   0   0]
 take -4 times row 3 plus row 1
 take -3/7 times row 3 plus row 2
[1 2 3 0]
[0 0 1 0]
[0 0 0 1]
[0 0 0 0]
 take -3 times row 2 plus row 1
[1 2 0 0]
[0 0 1 0]
[0 0 0 1]
[0 0 0 0]
\end{lstlisting}

These are naive implementations of Gauss's Method that do not try to 
work under stressful conditions, such as
very small leading entries\Dash they are just for fun.
But they do illustrate perfectly the point made in the Preface, 
since a person
builds intuition by doing a reasonable number of reasonably hard Gauss's Method
reductions by hand, and at that point automation can take over.

\textit{Code comment:} lines~50 and~88 are too long
for this page so they end with a 
slash~\inlinecode{\\} to make \python{} continue on the
next line. 

\lstinputlisting{gauss_method.sage}
\endinput


TODO:
