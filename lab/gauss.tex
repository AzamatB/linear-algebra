\chapter{Gauss's Method}

You can represent a equation in \Sage, make a list of them, and
solve the resulting system.
You can also use the matrix representation. 



\section{Systems}
To enter a system of equations you must first enter single equations, and
that requires entering variables.
We have seen one kind of variable in giving \Sage{} commands like these.
\begin{lstlisting}[style=python]
sage: x = 3
sage: 7*x
21  
\end{lstlisting}
Here, $x$ isn't an unknown, an indeterminant.  
Instead, $x$ is a named location where you can store values.
To illustrate the difference enter this.
\begin{lstlisting}[style=python]
sage: y
\end{lstlisting}
You get \lstinline[style=inline]!NameError: name 'y' is not defined!.
So you need to
declare to the system that something is a symbolic variable.
\begin{lstlisting}[style=python]
sage: var('x,y')
sage: x
x
\end{lstlisting}
With that, a system of equations is a list.
\begin{lstlisting}[style=python]
sage: var('x,y,z')                                  
(x, y, z)
sage: eqns = [x-y+2*z == 4, 2*x+2*y == 12, x-4*z==5]
sage: solve(eqns, x,y,z)                            
[[x == 5, y == 1, z == 0]]
\end{lstlisting}
Note that you must write double equals \lstinline[style=inline]!==! instead of 
the assignment operator \lstinline[style=inline]!=! and
you must also write
\lstinline[style=inline]!2*x! instead of  
\lstinline[style=inline]!2x!.
Either mistake will give you  
\lstinline[style=inline]!SyntaxError: invalid syntax!.

You can put a parameter in the right side and solve for the variables
in terms of the parameter.
\begin{lstlisting}[style=python]
sage: var('x,y,z,a')                                
(x, y, z, a)
sage: eqns = [x-y+2*z == a, 2*x+2*y == 12, x-4*z==5]
sage: solve(eqns, x,y,z)  
[[x == 2/5*a + 17/5, y == -2/5*a + 13/5, z == 1/10*a - 2/5]] 
\end{lstlisting}



\subsection{Matrices}
The \textit{solve} routine is a general-purpose tool, and will also 
do nonlinear systems. 
We want the special case of linear systems.
For that, matrix notation is the best tool.
 
Most of the matrices will have entries that are fractions
(we will see some other numbers later).
\Sage{} uses `QQ' for the rational numbers,
`RR' for the reals,
`CC' for the complex numbers,
and
`ZZ' for the integers.
And, \Sage{} takes a matrix row as a list, and
you enter the array as a list of rows.
\begin{lstlisting}[style=python]
sage: M = matrix(QQ,[[1, 2, 3], [4, 5, 6], [7 ,8, 9]])
sage: M
[1 2 3]
[4 5 6]
[7 8 9]
sage: M[1,2]
6
sage: M.nrows()
3
sage: M.ncols()
3
\end{lstlisting}
\Sage{} lists are zero-indexed, so \lstinline[style=inline]!M[1,2]! asks
for the entry in the second row and third column. 

Enter a vector in much the same way.
\begin{lstlisting}[style=python]
sage: v = vector(QQ, [2/3, -1/3, 1/2])
sage: v
(2/3, -1/3, 1/2)
sage: v[1]
-1/3
\end{lstlisting}
This is a column vector; 
it has rounded brackets so it looks different than a one-row matrix.

Finally, augmented a matrix with a vector in this way.
\begin{lstlisting}[style=python]
sage: M_prime = M.augment(v)
sage: M_prime
[ 1  2  3 10]
[ 4  5  6 11]
[ 7  8  9 12]  
\end{lstlisting}
You can tell \Sage{} to remember the distinction between the two parts 
of $M^\prime$.
\begin{lstlisting}[style=python]
sage: M_prime = M.augment(v,subdivide=True)
sage: M_prime                              
[ 1  2  3|10]
[ 4  5  6|11]
[ 7  8  9|12] 
\end{lstlisting}



\subsection{Row operations}
Computers are good for jobs that are tedious and error-prone.
Row operations are tedious.
We begin with a matrix.
\begin{lstlisting}[style=python]
sage: M = matrix(QQ,[[0, 2, 1], [2, 0, 4], [2 ,-1/2, 3]])
sage: v = vector(QQ, [2, 1, -1/2])                        
sage: M_prime = M.augment(v, subdivide=True)              
sage: M_prime                                             
[   0    2    1|   2]
[   2    0    4|   1]
[   2 -1/2    3|-1/2]
\end{lstlisting}
Swap the top rows (remember that row indices start with zero).
\begin{lstlisting}[style=python]
sage: M_prime.swap_rows(0,1)
sage: M_prime
[   2    0    4|   1]
[   0    2    1|   2]
[   2 -1/2    3|-1/2]
\end{lstlisting}
Next, rescale the top row.
\begin{lstlisting}[style=python]
sage: M_prime.rescale_row(0, 1/2)
sage: M_prime
[   1    0    2| 1/2]
[   0    2    1|   2]
[   2 -1/2    3|-1/2]  
\end{lstlisting}
Now get a new  bottom row by adding $-2$~times the top to the current bottom
row.
\begin{lstlisting}[style=python]
sage: M_prime.add_multiple_of_row(2,0,-2)
sage: M_prime
[   1    0    2| 1/2]
[   0    2    1|   2]
[   0 -1/2   -1|-3/2]  
\end{lstlisting}
Finish by finding echelon form.
\begin{lstlisting}[style=python]
sage: M_prime.add_multiple_of_row(2,1,1/4)
sage: M_prime                             
[   1    0    2| 1/2]
[   0    2    1|   2]
[   0    0 -3/4|  -1]  
\end{lstlisting}
(\Sage{} would have given us echelon form in a single operation with
\lstinline[style=inline]!M_prime.echelon_form()!.)
Now back substitution gives the solution, or we can ask \Sage.
\begin{lstlisting}[style=python]
sage: var('x,y,z')
sage: eqns=[-3/4*z == -1, 2*y+z == 2, x+2*z == 1/2]
sage: solve(eqns, x, y, z)
[[x == (-13/6), y == (1/3), z == (4/3)]]
\end{lstlisting}

% Needed?
The operations \Sagecmd{swap\_rows},
\Sagecmd{rescale\_rows}, and \Sagecmd{add\_multiple\_of\_row}
change the matrix.
\Sage{} has commands that leave the starting matrix unchanged but
return a changed matrix.
\begin{lstlisting}[style=python]
sage: M = matrix(QQ,[[1/2, 1, -1], [1, -2, 0], [2 ,-1, 1]])
sage: v = vector(QQ, [0, 1, -2])
sage: M_prime = M.augment(v, subdivide=True) 
sage: M_prime
[1/2   1  -1|  0]
[  1  -2   0|  1]
[  2  -1   1| -2]
sage: N = M_prime.with_rescaled_row(0,2)
sage: M_prime
[1/2   1  -1|  0]
[  1  -2   0|  1]
[  2  -1   1| -2]
sage: N      
[ 1  2 -2| 0]
[ 1 -2  0| 1]
[ 2 -1  1|-2]  
\end{lstlisting}
Here, $M^\prime$ is unchanged while the routine returns the
changed matrix that was saved as $N$.
There are also \Sagecmd{with\_swapped\_rows} 
and \Sagecmd{with\_added\_multiple\_of\_row} methods.




\subsection{Nonsingular and singular systems}
Resorting to \Sagecmd{solve} after doing the row operations is a waste.
\Sage{} will give a solution straight from the augmented matrix.
\begin{lstlisting}[style=python]
sage: M_prime.rref()
[    1     0     0|-13/6]
[    0     1     0|  1/3]
[    0     0     1|  4/3]
\end{lstlisting}

That system is nonsingular.
A reduced row echelon form system that has columns without a leading variable
is singular.
This one has a final column with zeroes in the rows that are all zeros on the
left, and so has infinitely many solutions.
\begin{lstlisting}[style=python]
sage: M = matrix(QQ,[[1, 1, 1], [1, 2, 3], [2 , 3, 4]])    
sage: v = vector(QQ, [0, 1, 1]) 
sage: M_prime = M.augment(v, subdivide=True)
sage: M_prime
[1 1 1|0]
[1 2 3|1]
[2 3 4|1]
sage: M_prime.rref()
[ 1  0 -1|-1]
[ 0  1  2| 1]
[ 0  0  0| 0]  
\end{lstlisting}
 
This singular system has a row that is zeros on the left but is nonzero
on the right, and so has no solution.
\begin{lstlisting}[style=python]
sage: v = vector(QQ, [0, 1, 2])             
sage: M_prime = M.augment(v, subdivide=True)
sage: M_prime.rref()                        
[ 1  0 -1| 0]
[ 0  1  2| 0]
[ 0  0  0| 1]
\end{lstlisting}

Get a tuple containing the number of the columns having leading entries with 
the \Sagecmd{pivots} method
(there is a complementary \Sagecmd{nonpivots}).
\begin{lstlisting}[style=python]
sage: v = vector(QQ, [0, 1, 2])
sage: M_prime                  
[1 1 1|0]
[1 2 3|1]
[2 3 4|2]
sage: M_prime.pivots()         
(0, 1, 3)
sage: M_prime.rref()
[ 1  0 -1| 0]
[ 0  1  2| 0]
[ 0  0  0| 1]  
\end{lstlisting}
Since in a linear system the 
free variables are associated with columns on the left of the augmented 
matrix that do not have 
a leading entry, because column~$2$ is not in the list of pivots we know the
system is singular.
(And, because column~$3$ is in the list of pivots we know that 
the system has no solution.)

We can use this observation to write a routine that decides if a 
square matrix is nonsingular.
\begin{lstlisting}[style=python]
sage: def check_nonsingular(mat):
....:     if not(mat.is_square()):
....:         print "ERROR: mat must be square"
....:         return
....:     p = mat.pivots()
....:     for col in range(mat.ncols()):
....:         if not(col in p):
....:             print "nonsingular"
....:             break
....:          
sage: N = Matrix(QQ, [[1, 2, 3], [4, 5, 6], [7, 8, 9]])
sage: check_nonsingular(N)                                
nonsingular
sage: N = Matrix(QQ, [[1, 0, 0], [0, 1, 0], [0, 0, 1]])
sage: check_nonsingular(N)                                   
\end{lstlisting}
Actually, \Sage{} matrices already have a method \Sagecmd{is\_singular}
but this illustrates writing routines to extend the system.



\subsection{Infinitely many solutions}
\Sage{} will give you the solution set of a system using \Sagecmd{solve}.
Here we start with a matrix of coefficients having the top two rows add to
the bottom row.
\begin{lstlisting}[style=python]
sage: M = matrix(QQ,[[1, 1, 1], [1, 2, 3], [2 , 3, 4]])    
sage: v = vector(QQ, [1, 0, 1])                            
sage: M_prime = M.augment(v, subdivide=True)               
sage: eqns = [x+y+z == 1, x+2*y+3*z == 0, 2*x+3*y+4*z == 1]
sage: solve(eqns, x, y)   
[[x == z + 2, y == -2*z - 1]]  
sage: solve(eqns, x, y, z)                                 
[[x == r1 + 2, y == -2*r1 - 1, z == r1]]
\end{lstlisting}
In the first of the two calls to \Sagecmd{solve} we ask \Sage{} 
to solve for only $x$ and~$y$ and we get the solution in terms of~$z$.
In the second call \Sage{} produces a parameter of its own.   




%========================================
\section{Script}

We finish with a fun routine that automates the by-hand row reduction of
the homework.

This script uses the matrix capabilities of \Sage{} to both describe 
and perform the row operations needed to reduct a given matrix to 
either echelon form or reduced echelon form. 

\subsection{Loading and running}
The source file of the script is at the end of this section but 
first here are 
a few sample usages.
\begin{lstlisting}[style=python]
sage: M = matrix(QQ, [[1/2, 1, 4], [2, 4, -1], [1, 2, 0]])          
sage: v = vector(QQ, [-2, 5, 4])
sage: M_prime = M.augment(v, subdivide=True)  
sage: gauss_method(M_prime)
[1/2   1   4| -2]
[  2   4  -1|  5]
[  1   2   0|  4]
 take -4 times row 1 plus row 2
 take -2 times row 1 plus row 3
[1/2   1   4| -2]
[  0   0 -17| 13]
[  0   0  -8|  8]
 take -8/17 times row 2 plus row 3
[  1/2     1     4|   -2]
[    0     0   -17|   13]
[    0     0     0|32/17]
\end{lstlisting}

In the remaining examples we skip the extra steps to make an augmented matrix. 
\begin{lstlisting}[style=python]
sage: M1 = matrix(QQ, [[2, 0, 1, 3], [-1, 1/2, 3, 1], [0, 1, 7, 5]])
sage: gauss_method(M1)
[  2   0   1   3]
[ -1 1/2   3   1]
[  0   1   7   5]
 take 1/2 times row 1 plus row 2
[  2   0   1   3]
[  0 1/2 7/2 5/2]
[  0   1   7   5]
 take -2 times row 2 plus row 3
[  2   0   1   3]
[  0 1/2 7/2 5/2]
[  0   0   0   0]  
\end{lstlisting}

The script has a routine to go all the way to reduced echelon form.
\begin{lstlisting}[style=python]
sage: M2 = matrix(QQ,
....:             [[1, 2, 3, 4], [1, 2, 3, 4],
....:              [2, 4, -1, 5], [1, 2, 0, 4]])
sage: gauss_jordan(M2)            
[ 1  2  3  4]
[ 1  2  3  4]
[ 2  4 -1  5]
[ 1  2  0  4]
 take -1 times row 1 plus row 2
 take -2 times row 1 plus row 3
 take -1 times row 1 plus row 4
[ 1  2  3  4]
[ 0  0  0  0]
[ 0  0 -7 -3]
[ 0  0 -3  0]
 swap row 2 with row 3
[ 1  2  3  4]
[ 0  0 -7 -3]
[ 0  0  0  0]
[ 0  0 -3  0]
 take -3/7 times row 2 plus row 4
[  1   2   3   4]
[  0   0  -7  -3]
[  0   0   0   0]
[  0   0   0 9/7]
 swap row 3 with row 4
[  1   2   3   4]
[  0   0  -7  -3]
[  0   0   0 9/7]
[  0   0   0   0]
 take -1/7 times row 2
 take 7/9 times row 3
[  1   2   3   4]
[  0   0   1 3/7]
[  0   0   0   1]
[  0   0   0   0]
 take -4 times row 3 plus row 1
 take -3/7 times row 3 plus row 2
[1 2 3 0]
[0 0 1 0]
[0 0 0 1]
[0 0 0 0]
 take -3 times row 2 plus row 1
[1 2 0 0]
[0 0 1 0]
[0 0 0 1]
[0 0 0 0]
\end{lstlisting}

These are naive implementations of Gauss's Method that do not try to 
work under stressful conditions\Dash just for fun.

\textit{Comment:} lines~50 and~88 are too long
to display cleanly on this page so they end a 
slash~\lstinline[style=inline]!\! to make \python{} continue on the
next line. 

\lstinputlisting{gauss_method.sage}
\endinput


TODO:
