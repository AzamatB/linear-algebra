\chapter{Maps}


We've used \Sage{} to define vector spaces.
Next we explore operations that we can do on vector spaces.
  

%========================================
\section{Left/right}
We first note that \Sage{} represents linear
maps differently than the book does.
Rather than quarrel with the tool, below we will do it
\Sage's way.

Consider the application of a linear map 
to a member of a vector space
$t(\vec{v})$.
For example, 
with this function $\map{t}{\Re^2}{\Re^3}$ and this element of the domain
\begin{equation*}
  t(\colvec{a \\ b})
  =\colvec{a+b \\ a-b \\ b}
  \qquad
  \vec{v}=\colvec{1 \\ 2}
\end{equation*}
the map application gives this.
\begin{equation*}
  t(\colvec{1 \\ 2})
  =\colvec{3 \\ -1 \\ 2}
\end{equation*}

To represent it we must fix bases. 
In the example
we use the canonical bases $\stdbasis_2\subset\Re^2$ 
and~$\stdbasis\subset\Re^3$.
With respect to the bases the book finds  
a matrix~$T=\rep{t}{\stdbasis_2,\stdbasis_3}$ 
and a vector $\vec{w}=\rep{\vec{v}}{\stdbasis_2}$,
and represents $t(\vec{v})$ 
with the matrix-vector product $T\vec{w}$.
\begin{equation*}
  \begin{mat}
    1 &1 \\
    1 &-1 \\
    0 &1
  \end{mat}
  \colvec{1 \\ 3}
  =
  \colvec{4 \\ -2 \\ 3}
\end{equation*}
That is, the book is write right: its notation puts the vector on the right 
of the matrix.

This choice is a matter of taste and many authors instead
use a row vector that multiplies a matrix from the left.
\Sage{} falls in this camp.
\Sage{} represents the map application in this way.
\begin{equation*}
  \rowvec{1 &2}
  \begin{mat}
    1 &1  &0 \\
    1 &-1 &1
  \end{mat}
  =
  \rowvec{4 &-2 &3}
\end{equation*}
Obviously the difference is cosmetic but can be confusing.
The translation is that, compared to the book's representation $T\vec{w}$,
\Sage{} prefers the transpose
$\trans{(T\vec{w})}=\trans{\vec{w}}\;\trans{T}$.



  

%========================================
\section{Defining}
We will see two different ways to define a linear transformation.

\subsection{Symbolically}
We first define a map that takes two inputs and returns three outputs.
Ww need not yet define a domain and codomain 
so this not a function\Dash instead it is a prototype for a function.
% \begin{lstlisting}
% sage: a, b = var('a, b')   
% T_symbolic(a, b) = [a+b, a-b, b]         
% sage: T_symbolic       
% (a, b) |--> (a + b, a - b, b)                
% \end{lstlisting}
\begin{sageoutput}
a, b = var('a, b')   
T_symbolic(a, b) = [a+b, a-b, b]         
T_symbolic       
\end{sageoutput}
Make an instance of a function by applying $T_{\textit{symbolic}}$ on a 
particular domain and codomain.
\begin{sageoutput}[d,0,2;s,7,68,60;s,8,70,60]
a, b = var('a, b')   
T_symbolic(a, b) = [a+b, a-b, b]         
T = linear_transformation(RR^2, RR^3, T_symbolic)
T                                              
\end{sageoutput}
% \begin{lstlisting}
% sage: T = linear_transformation(RR^2, RR^3, T_symbolic)
% sage: T                                                
% Vector space morphism represented by the matrix:
% [ 1.00000000000000  1.00000000000000 0.000000000000000]
% [ 1.00000000000000 -1.00000000000000  1.00000000000000]
% Domain: Vector space of dimension 2 over Real Field with 53 bits of 
%     precision
% Codomain: Vector space of dimension 3 over Real Field with 53 bits of 
%     precision
% \end{lstlisting}
Note the left/right issue again: \Sage's matrix is the transpose of
the matrix the book would use.

Evaluating this function on a member of the domain gives a member
of the codomain. 
\begin{sageoutput}[d,0,3]
a, b = var('a, b')   
T_symbolic(a, b) = [a+b, a-b, b]         
T = linear_transformation(RR^2, RR^3, T_symbolic)
v = vector(RR, [1, 3])  
T(v)
\end{sageoutput}
% \begin{lstlisting}
% sage: v = vector(RR, [1, 3])  
% sage: T(v)
% (4.00000000000000, -2.00000000000000, 3.00000000000000)
% \end{lstlisting}

\Sage{} can compute the interesting things about the transformation.
Here it finds the null space 
and range space, using the equivalent 
terms \textit{kernel} and \textit{image}.
\begin{sageoutput}[d,0,3;s,4,70,58;s,8,70,58]
a, b = var('a, b')   
T_symbolic(a, b) = [a+b, a-b, b]         
T = linear_transformation(RR^2, RR^3, T_symbolic)
T.kernel()                                       
T.image()                                        
\end{sageoutput}
% \begin{lstlisting}
% sage: T.kernel()                                       
% Vector space of degree 2 and dimension 0 over Real Field with 53 bits 
%     of precision
% Basis matrix:
% []
% sage: T.image()                                        
% Vector space of degree 3 and dimension 2 over Real Field with 53 bits 
%     of precision
% Basis matrix:
% [  1.00000000000000  0.000000000000000  0.500000000000000]
% [ 0.000000000000000   1.00000000000000 -0.500000000000000]
% \end{lstlisting}
The null space's basis is empty because 
it is the trivial subspace of the domain,
with dimension~$0$.
Therefore $T$ is one-to-one.

The range space has a $2$-vector basis. 
This agrees with the theorem that
the dimension of the null space plus the dimension of the 
range space equals to the dimension of the domain.

For contrast consider a map that is not one-to-one.
\begin{sageoutput}[s,8,68,62;s,9,70,62]
S_symbolic(a, b) = [a+2*b, a+2*b]
S_symbolic
S = linear_transformation(RR^2, RR^2, S_symbolic)
S
v = vector(RR, [1, 3])  
S(v)
\end{sageoutput}
% \begin{lstlisting}
% sage: S_symbolic(a, b) = [a+2*b, a+2*b]
% sage: S_symbolic
% (a, b) |--> (a + 2*b, a + 2*b)
% sage: S = linear_transformation(RR^2, RR^2, S_symbolic)
% sage: S
% Vector space morphism represented by the matrix:
% [1.00000000000000 1.00000000000000]
% [2.00000000000000 2.00000000000000]
% Domain: Vector space of dimension 2 over Real Field with 53 bits of 
%     precision
% Codomain: Vector space of dimension 2 over Real Field with 53 bits of 
%     precision
% sage: S(v)
% (7.00000000000000, 7.00000000000000)
% \end{lstlisting}
This map is not one-to-one since the input $(a,b)=(2,0)$  gives
the same result as~$(a,b)=(0,1)$.  
\Sage{} confirms this.
\begin{sageoutput}[d,0,2;s,3,69,58;s,7,70,59]
S_symbolic(a, b) = [a+2*b, a+2*b]
S = linear_transformation(RR^2, RR^2, S_symbolic)
S.kernel()
S.image()
\end{sageoutput}
% \begin{lstlisting}
% sage: S.kernel()
% Vector space of degree 2 and dimension 1 over Real Field with 53 bits 
%     of precision
% Basis matrix:
% [  1.00000000000000 -0.500000000000000]
% sage: S.image()
% Vector space of degree 2 and dimension 1 over Real Field with 53 bits 
%     of precision
% Basis matrix:
% [1.00000000000000 1.00000000000000]  
% \end{lstlisting}
The null space has nonzero dimension, namely it 
has dimension~$1$,
so the map is not one-to-one.

Without looking at the range space we know that its dimension must be~$1$ 
because the dimensions of the null and range spaces add to the
the dimension of the domain.
Again, \Sage{} confirms our calculation.



\subsection{Via matrices}
If we fix a space for the domain and a space for the codomain, and bases for
each, then \Sage{} lets us define a transformation by specifying 
the matrix representing its action.
\begin{sageoutput}[s,6,68,62;s,7,70,62]
M = matrix(RR, [[1, 2, 3], [4, 5, 6]])
m = linear_transformation(M)
m  
\end{sageoutput}
Note again that \Sage{} prefers the representation where the vector multiplies
from the left.
\begin{sageoutput}
M = matrix(RR, [[1, 2, 3], [4, 5, 6]])
m = linear_transformation(M)
v = vector(RR, [7, 8])
m(v)  
\end{sageoutput}
\Sage{} has done this calulation.
\begin{equation*}
  \colvec{7 &8}
  \begin{mat}
    1 &2 &3 \\
    4 &5 &6
  \end{mat}
  =\colvec{39 &54 &69}
\end{equation*}

If you have a matrix from the book, intended for a vector-on-the-right
calculation, \Sage{} will make the necessary adjustment.
\begin{sageoutput}
N = matrix(RR, [[1, 4], [2, 5], [3, 6]])
n = linear_transformation(N, side='right')
v = vector(RR, [7, 8])
n(v)  
\end{sageoutput}

% \begin{lstlisting}
% sage: A = matrix(RR, [[1, 2], [3, 4]])
% sage: A
% [1.00000000000000 2.00000000000000]
% [3.00000000000000 4.00000000000000]
% sage: F = linear_transformation(RR^2, RR^2, A, side='right')
% sage: F
% Vector space morphism represented by the matrix:
% [1.00000000000000 3.00000000000000]
% [2.00000000000000 4.00000000000000]
% Domain: Vector space of dimension 2 over Real Field with 53 bits of 
%     precision
% Codomain: Vector space of dimension 2 over Real Field with 53 bits of 
%     precision
% \end{lstlisting}
(Again note that the matrix \Sage{} shows by default is the one for 
\inlinecode{side='left'}.)
This was created with the same \inlinecode{linear_transformation} operation
and it also is a function.
\begin{lstlisting}
sage: v = vector(RR, [1, -1])
sage: F(v)
(-1.00000000000000, -1.00000000000000)  
\end{lstlisting}
We can ask the same questions about this function.
\begin{lstlisting}
sage: F.kernel()
Vector space of degree 2 and dimension 0 over Real Field with 53 bits 
    of precision
Basis matrix:
[]
sage: F.image()
Vector space of degree 2 and dimension 2 over Real Field with 53 bits 
    of precision
Basis matrix:
[ 1.00000000000000 0.000000000000000]
[0.000000000000000  1.00000000000000]
\end{lstlisting}
The null space of $F$ is the trivial subspace of $\Re^2$ and so this function
is one-to-one.
The range space is all of $\Re^2$.
\begin{lstlisting} 
sage: F.image() == RR^2
True
\end{lstlisting}





%========================================
\section{Operations}

If we fix a domain and codomain then 
the set of linear transformations has some natural operations.
\Sage{} can define those operations. 

\subsection{Addition}
First, create a function to add to the prior one. 
\begin{lstlisting}
sage: B = matrix(RR, [[1, -1], [2, -2]])
sage: G = linear_transformation(RR^2, RR^2, B, side='right')
sage: G
Vector space morphism represented by the matrix:
[ 1.00000000000000  2.00000000000000]
[-1.00000000000000 -2.00000000000000]
Domain: Vector space of dimension 2 over Real Field with 53 bits of 
    precision
Codomain: Vector space of dimension 2 over Real Field with 53 bits of 
    precision
\end{lstlisting}

Now we define the sum of the two by $F+G\,(\vec{v})$ is the map taking
$\vec{v}$ to the sum of the two vectors $F(\vec{v})$ and $G(\vec{v})$.
\begin{lstlisting}
sage: H = F+G
sage: F(v)+G(v)
(1.00000000000000, 3.00000000000000)
sage: H(v)
(1.00000000000000, 3.00000000000000)  
\end{lstlisting}

The sum of two matrices is defined as the operation on the representations
that yields the representation of the function sum.
\begin{lstlisting}
sage: F.matrix(side='right')
[1.00000000000000 2.00000000000000]
[3.00000000000000 4.00000000000000]
sage: G.matrix(side='right')
[ 1.00000000000000 -1.00000000000000]
[ 2.00000000000000 -2.00000000000000]
sage: H.matrix(side='right')
[2.00000000000000 1.00000000000000]
[5.00000000000000 2.00000000000000]  
\end{lstlisting}

The scalar multiple of a function and the scalar multiple of a matrix are
defined analgously, except that we must write the scalar on the right.
\begin{lstlisting}
sage: F(v)
(-1.00000000000000, -1.00000000000000)
sage: H = F*3
sage: H(v)
(-3.00000000000000, -3.00000000000000)  
\end{lstlisting}





\subsection{Composition}

\subsection{Inverse}




%========================================
% \section{One-to-one and Onto}




%========================================
\section{Alternate bases}






\endinput


TODO:
